#!/usr/bin/python3
# -*- coding: utf-8 -*-
#import python packages

#install --> (sudo) apt-get install python-pip --> (sudo) pip install pillow python-ev3dev
#running --> run (sudo) python pythonfilename.py imagefilename.png (jpg will work along with others types) -->
#            you will be given a dialogue --> just type "" and return/enter to continue

from PIL import Image, ImageFilter
import ev3dev.ev3 as ev3
import time
import os
import sys

# paper resolution
vert_move = 15;
horiz_move = 15;
res = (horiz_deg/horiz_move);

#function to ensure the motor has stopped before moving on
xxx = 0
def waitformotor(motor):
    while motor.state != []:
        xxx = 0
# define motors and use brake mode

paper = ev3.MediumMotor('outA')
pen1 = ev3.MediumMotor('outB')
pen2 = ev3.MediumMotor('outD')
head = ev3.MediumMotor('outC')

pen1.stop_action = "brake"
pen2.stop_action = "brake"
head.stop_action = "brake"
paper.stop_action = "brake"
LR.reset()
pen1.reset()
pen2.reset()
paper.reset()


#move paper until color sensor recieves >50 reading

#paper.speed_regulation_enabled=u'on'
pen1.run_to_rel_pos(speed_sp=-100, position_sp=-53)
pen2.run_to_rel_pos(speed_sp=100, position_sp=53)
waitformotor(pen)
waitformotor(pen2)
pen1.reset()
pen2.reset()
print "pen up"


#make a function to make a dot on the page
def makedot(pen,dir):
    pen.run_to_rel_pos(speed_sp=100*dir, position_sp=55*dir)
    waitformotor(pen) #double check if motor is stopped before raising pen
    pen.run_to_rel_pos(speed_sp=-100*dir, position_sp=-53*dir
    waitformotor(pen) #double check if motor is stopped before raising pen

#resize and flip image
filename = sys.argv[1]

w = 0
h = 0
l = 0
img2 = Image.open(filename) #open image
img=img2.convert("RGBA")
width, height = img.size # get image size

#define variables
array = []
w = width-1 #define starting width counter
print width," x ", height
r_array=[]
g_array = []
b_array = []
bl_array = []

#different colors: (in rgba -- remove last number in set to convert to rgb)
#red = (255,0,0,0) eg. in rgb -- (255,0,0)
#green = (0,255,0,0)
#blue = (0,0,255,0)
#black = (0,0,0,0)
#white = (255,255,255,0)

print img.getpixel((w,h))

while h != height:
        while w != -1:
                array.append(img.getpixel((w, h))) #get rgba black or white of each pixel and write to full array
                r,g,b,a = img.getpixel((w, h)) #get rgba of each pixel
                #check if red, green, or blue is greatest in rgb values --- check if black or white also --> then append array differently for each switch case
                if r > g and r > b :
                    r_array.append(0)
                    g_array.append(255)
                    b_array.append(255)
                    bl_array.append(255)
                    print(colored("█","red"), end="")
                elif g > r and g > b :
                    g_array.append(0)
                    r_array.append(255)
                    b_array.append(255)
                    bl_array.append(255)
                    print(colored("█","green"), end="")
                elif b > r and b > g :
                    b_array.append(0)
                    g_array.append(255)
                    r_array.append(255)
                    bl_array.append(255)
                    print(colored("█","blue"), end="")
                elif b < 50 and r < 50 and g < 50 :
                    b_array.append(255)
                    g_array.append(255)
                    r_array.append(255)
                    bl_array.append(0)
                    print ("█", end="")
                else:
                    b_array.append(255)
                    g_array.append(255)
                    r_array.append(255)
                    bl_array.append(255)
                     print(" ", end="")
                w = w-1 #move to next pixel -- use -1 to flip image -> make images not backward when printed
                print("")
        w = width-1 #reset width counter
        h = h+1 #move to next row

"""
img2 = Image.open("ev3screen.jpg")
raw = img2.tobytes()
image = Image.frombytes(img2.mode, img2.size, raw)
lcd = ev3.Screen()
lcd._img.paste(image, (0, 0))
lcd.update()
"""

x = input('Is this picture ok?>>') #wait for dialogue to be answered then start printing
input("Press Enter to continue...")

all_pixels = bl_array 
all_pixels2 = b_array
xd = 0
yd = 0
xda = 0 
while yd != height:
    while xd != width:
        if all_pixels[xda] == 0: #is pixel black?
            print("█", end="") #print block if black pixel
            head.run_to_abs_pos(position_sp=horiz_move*xd, speed_sp=400, ramp_down_sp=500)
            waitformotor(head)
            # lower and raise pen
            makedot(pen1,-1)
            # move pen left	
        elif all_pixels2[xda] == 0:
            print(colored("█","red"), end="") #print block if red pixel
            head.run_to_abs_pos(position_sp=(horiz_move*xd)+319, speed_sp=400, ramp_down_sp=500)
            waitformotor(LR)
            # lower and raise pen
            makedot(pen2,1)
	else:
            print(" ", end="")
            #move pen left
        xd = xd + 1
        xda = xda + 1

    print("; PCT: "+str(100*xda/len(all_pixels))+"%")
    yd = yd + 1
    xd = 0
    # move paper forward
    paper.run_to_abs_pos(position_sp=vert_move*(yd), speed_sp=250,ramp_down_sp=500)
    # reset pen location
    waitformotor(paper)

#reset paper location
paper.run_to_abs_pos(position_sp=0, speed_sp=1000)
LR.run_to_abs_pos(position_sp=0, speed_sp=1000)
pen.run_to_abs_pos(position_sp=0, speed_sp=1000)
pen2.run_to_abs_pos(position_sp=0, speed_sp=1000)
waitformotor(paper)
waitformotor(head)
waitformotor(pen1)
waitformotor(pen2)
